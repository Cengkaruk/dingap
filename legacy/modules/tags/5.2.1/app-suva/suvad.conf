# ClarkConnect Suva/2 Configuration

# You can use '#' for marking comment lines.  Keywords may not contain spaces.
# If a value must contain spaces, it should be quoted with " or '.  Keywords
# and values are seperated by an equals sign.  The end of a statement,
# keyword = value pair, is terminated with a semi-colon (with the exception of
# definition blocks).  Definition blocks are defined using { and } characters.
# All other white-space is ignored.

# See suvad.conf(5) for configuration documentation.

# Global configuration options
###############################################################################

# Debug mode?
# If you have a need to prevent Suva from becoming a background process and/or
# you need to see (huge) amounts of extra debug (and warning) messages, then
# enable this option.
#debug = true;

# Log level mask.  Used to select which message levels are logged.
# Seperate levels using a pipe, '|', character.  Valid log levels are:
#  DEBUG - This will output all development debug output.
#  INFO  - Informational/normal messages.
#  WARN  - Warning messages.
#  FAIL  - Failure message, should always be enabled.
#  ALL   - All of the above.
log-levels = ALL;

# Log type mask.  This mask will allow you to see only certain types of
# messages generated by various areas of Suva.  Note:  You will only see
# those messages that have first matched the above log-level.
# Seperate levels using a pipe, '|', character.  Valid log types are:
#  GLOBAL   - Main application messages.
#  DATABASE - Database related messages.
#  SOCKET   - Socket related messages.
#  SIGNAL   - Messages generated by signals.
#  CHILD    - Child creation/management messages.
#  CONFIG   - Configuration loading/validation messages.
#  CIPHER   - Cryptography messages, AES and RSA.
#  AUTH     - Authentication messages.
#  KEY      - Key generation/rotation messages.
#  SFD      - Suva front-door plug-in messages.
#  MARK     - Developer MARK messages.
#  IPC      - Inter-process communication related messages.
#  PROFILE  - Time-profiling messages (if compiled in).
#  TRACE    - Stack back-trace messages (for debugging).
#  ALL      - All of the above.
log-types = ALL;

# Server port address(es).  STL (Suva transport layer) socket address.
# To specify an STL port, use the following format:
#  inet = <name>:<port>
#  pipe = <name>:<socket path>
stl-port {
	inet = all:1875;
}

# Front door plug-ins.  Suva is by default a secure tunnel server only.  If you
# need RPC (application session) support, you will need to load a "font door"
# plug-in that can retrieve session configuration parameters from an incoming
# client connection.  See doc/front-door.txt for more information.
# To specify a font door plug-in, use the following format:
#  plug-in = <name>:<plug-in library>
plug-in {
	# NOTE: The <plug-in library> refers to the "base" name of the library
	# without a path, prefix, and/or postfix.  Ex: libscl.so -> scl
}

# Front door access ports.  Bind port addresses (or pipes) to front door
# plug-ins.  To bind on all interfaces (0.0.0.0), use "all" for <interface>.
#  pipe-listen = <name>:<plug-in name>:<socket path>;
#  inet-listen  = <name>:<plug-in name>:<interface>:<listen port>;
front-door {
}

# Organizations
###############################################################################

# An example organization configuration
organization clearcenter.com
{
	# Mandatory device name.  Valid characters are A-z0-9.- up to 255
	# characters.
	device-name = 0;

	# Mandatory device hostkey.  Must be a 32 character hexadecimal string.
	# There is a script keys/mkhost.sh script to generate a PRNG key.
	device-hostkey = 00000000000000000000000000000000;

	# Administrative organizations are able to configure Suva remotely.
	administrator = false;

	# This is where keys are stored and retrieved from:
	key-dir = "/var/lib/suva/clearcenter.com";

	# Time-to-live for polled public keys.  After this period of time
	# expires (in seconds) the Suva client will perform another key poll
	# for this organization.
	key-cache-ttl = 3600;

	# Key poll success threshold.  When a key poll completes, the returned
	# public keys are compared.  Identical keys are grouped and counted.
	# The group with the highest "score" must be equal to or over this
	# threshold percentage.  For example, if you have three key servers,
	# and two return the same key and the third returns a different key,
	# then in order for the key poll to be successful you would need to
	# set the threshold to 66%.
	key-poll-threshold = 66;

	# Key server list.  You must specify at leat one, but is highly
	# recommended that you define at least three organizational key servers.
	key-server {
		host = "key1.clearsdn.com:1975";
		host = "key2.clearsdn.com:1975";
		host = "key3.clearsdn.com:1975";
		host = "key4.clearsdn.com:1975";
		host = "key5.clearsdn.com:1975";
		host = "key6.clearsdn.com:1975";
	}

	# Application sessions.  Application sessions are specified with the
	# following format:
	#   execute = <name>:<fd-read>:<fd-write>:<application-path>[:<app-args>];
	application {
		# Default suvlet services which are installed by the compat-suvlets RPM
		execute = Blank:1:0:/var/lib/suvlets/Blank/Blank;
		execute = BWMeter:1:0:/var/lib/suvlets/BWMeter/BWMeter;
		execute = DeviceInfo:1:0:/var/lib/suvlets/DeviceInfo/DeviceInfo;
		execute = SecurityAudit:1:0:/var/lib/suvlets/SecurityAudit/SecurityAudit;
		execute = Snort:1:0:/var/lib/suvlets/Snort/Snort;
		execute = Software:1:0:/var/lib/suvlets/Software/Software;
		execute = RemoteBackupDebug:2:0:/usr/bin/sudo:"/var/webconfig/scripts/rbs-client.php -v";
	}

	# Tunnel configuration.  Here you can specify as many tunnel source
	# or destination points you require.  There are two types of # tunnels.
	# Listening (or source) tunnels listen on a port (or pipe) and connect
	# to the specified Suva server to complete the tunnel.
	#
	# Listening tunnels are specified with the following format:
	#   pipe-listen = <name>:<pipe-path>:<dest-host>:<dest-port>;
	#   inet-listen = <name>:<interface>:<listen-port>:<dest-host>:<dest-port>;
	#
	# Connecting (or destination) tunnels are completed by Suva when an
	# incoming tunnel connection with the same name has authenticated.
	#
	# Connecting tunnels are specified with the following format:
	#   pipe-connect = <name>:<flags>:<pipe-path>;
	#   inet-connect = <name>:<flags>:<dest-host>:<dest-port>;
	tunnel {
		# An example HTTP tunnel.  Listen and connect statements would
		# generally not appear together.
		#inet-listen = SuvaHTTP:eth0:8080:localhost:1975;
		#inet-connect = SuvaHTTP:0:google.com:80;
		pipe-listen = RemoteBackupControl:/var/lib/rbs/rb-control.socket:rsb.clearsdn.com:1875;
		inet-listen = RemoteBackupData:lo:3250:rsb.clearsdn.com:1875;
		inet-listen = RemoteBackupPortal:lo:3260:rsb.clearsdn.com:1875;
	}
}

# Maximum number of sockets to allocate.  This is more of a tuning option that
# would rarely need to be changed.  Be careful not to set this too low.
max-sockets = 24;

# Maximum number of children to fork.  Should not need to be adjusted.
# Set higher on a server, and keep low (16 - 32) for a client.
max-children = 16;

# Session key time-to-live.  The client-side will regenerate a new session
# key after the current key has been used for this number of seconds.
key-ttl = 30;

# The maximum number of seconds a key poll can take before returning whatever
# resulting public keys (if any).  It's recommended to set this to twice the
# value of the socket-ttl (set below).
poll-ttl = 8;

# Under Linux, children will not die after being used once.  They will linger
# in a pool awaiting another task.  Set this time-to-live to control the
# duration of the child before it suicides.  On a busy server it would be
# useful to use a larger value whereas clients could use a smaller value.
child-ttl = 60;

# The session time-to-live determines how long Suva will wait for "raw/scl"
# data before closing the connection.  The server-side of the connection will
# do the actual timing, so this has no effect on the client-side.
session-ttl = 240;

# The timeout used for socket operations (read/write and connect).
socket-ttl = 60;

# If you want to get run-time status information, enable this IPC pipe.
#external-ipc = true;

# When running in the default daemon mode, Suva will log output to syslog.
# Set this to the LOCAL syslog facility of your choice, 0 - 7.  For example, 3
# would use LOG_LOCAL3 (local3 in syslogd.conf).
facility = 0;

# End of suvad-client.conf-example
# vi: ts=4
